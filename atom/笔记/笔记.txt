总结归纳

1, pip下载：使用pip下载时候可以在包后面加上一个 -i 加上国内镜像网址、列如：pip install Django -i https://pypi.tuna.tsinghua.edu.cn/simple
2, print输出：print([object,...][,sep=' '][,end='\n'][file=sys.stdout][,flush=False])
            sep,在多个对象的文本表示，中间使用空格隔开，end表示结尾字符串，file指定输出流，按照flush决定是否刷新输入缓冲区
3, 文件扫描，逐行读取使用for语句
            for line in open("wenjianmin").readines():  #readings()  先把文件放入内存
                print(line.rstrip())

            for line in open (“wenjianmin”):        #read()  从文件中逐行读取
                print(line.rstrip())
4, 比较， is 是检查对象所储存的是否是同一地址， == 是检查对象的内容是否相同
5, 储存python原生对象, 模块 pickle （不需要对字符串进行文件转换）  储存：pickle.dump(内容) 取出：pickle.load(内容名)
6, json格式，可以使用json模块，json.dumps() json.loads() ,  struct模块，能把文件转化为二进制数据，
7, 不是 && 和||   , 且————>and  或————>or
8, python中的三目运算 A = y if x else z
9, 进制转化 ：bin() 转化为二进制， oct() 转化为八进制  hex()转化为十六进制  int() 可以转化为十进制
10, zip()  将两个或者两个以上的序列进行提取组合,也可以用于构造字典（会以最小的序列为长度）
          L1=[1,2,3,4] L2=[5,6,7,8]
          print(list(zip(L1,L2)))
        ==>  [(1,5),(2,6),(3,7),(4,8)]
          print(dict(zip(L1,L2)))
11, map()映射， print(list(map((lambda x:x+3),[1,2,3,4,5])))  ===> [4,5,6,7,8]
12, nonlocal()  限定变量的作用域在外面一层的函数中，能让外层作用域的名称被修改
13, global()    使变量的名称位于外层的模块中
14, 匿名函数:lambda, (lambda x: x**3)  在发生事件处理时，lambda直到事件发生时候才执行处理器，而不是在创建时候就发生
15, filter()  筛选器 print(list(filter((lambda x :x > 0),range(-5,5))))
16, 列表推导，[x + y for xin [1,2,3] for y in [12,34,45]]  ==>[13,36,48]
17, 装饰器， 遵循开放封闭的原则，在不改变原函数的基础上拓展函数的功能
            --定义--
            def decorater(func):    #这里必须要有传入函数（这里是传入了func1， 并将其重命名为func ），并在内部的函数中调用
                def wrapper():
                    func()      #要先调用一次原来的函数（使用传入后的名称）
                    ...
                    ...
                    ...
                return wrapper()
            如果原函数有参数，则wrapper也需要一个参数，func也需要一个

            @decorater()
            def func1():
                ...

            func1()  #在调用的时候地址发生了改变
            """

            def decorater(func):
                def wrapper():
                    func()
                    print('扩建')
                    print('装修')
                    print('升级')
                    print('落成')
                return wrapper

            @decorater
            def house():
                print('简陋屋子...')
18，高阶函数，max,min,sorted,filter等 需要使用lambda作为参数
19, 在一个函数中使用三个引号，即可为函数添加文档说明
20, 在系统的路径前面添加 ‘r’ 可以使反斜杠不再是转义字符
21, 文件判断是否可读，  .readable()返回布尔值。后面加able()一般是判断
22, os.path
      __file__   表示当前文件
      os.path.dirname(文件)  ---找出 文件 所在的目录
      os.path.join(路径，'文件名')  ---在 路径 下添加 文件
      os.path.abspath(文件)  ---找出 文件 所在的目录和文件名
      os.path.isdir(绝对路径)     ---判断对象是否是一个目录
      os.path.isfile(绝对路径)    ---判断对象是否是一个文件
      os.path.split(绝对路径)     ---分割文件目录和文件名
      os.path.splitext(绝对路径)     ---分割文件路径和文件后缀
      os.path.getsize(文件名)    ----返回文件的字节大小

      os.getcwd()   ---找出 当前文件所在目录
      os.listdir(‘目录’)  ---返回指定目录下的所有文件和文件名称
      os.mkdir("")        --创建文件夹  需给出路径和文件夹名称
      os.remove('路径及名称')   ---删除文件
      os.rmdir('目录')         ---删除空目录
      os.chdir('路径')          ---切换目录

23, 异常处理
      try:
        可能出现异常的代码
      except:
        发生错误执行的代码, 通常结合 异常的类型，相当于选择
        异常的父类不能放置在子类之前， 否则就不会跳转到相应的错误之中
        Exception是最大的错误父类
        except Exception as err；--->将会输出错误内容，而不会立即停止程序
      finally:
        无论什么情况都会执行的代码 （一般在文件和数据库操作中使用）
      raise Exception("")---> 主动抛出一个异常提示
24, captialize()---> 将字符串首字母大写，其他字母小写
25, 列表推导式 ---->  []
    集合推导式 ---->  {}
    字典推导式 ---->  {key:value ------}

26, 生成器---->  生成的数据只在需要时开始生成
      1，使用列表推导式   将推导式的方括号换成 小括号
            g = （num for num in range(100))
            生成：
              每调用一次生成一个值
              方法一，使用  g.__next__()
              方法二，使用  next(g)


      2, 使用函数，使用 yield 关键字
            生成同样使用  .__next__() or next() 完成
            三,   .seed('')  获取下一个数值，向每次生成中传递值，首次调用只能传递 None 值
            yield 一般用在协程的时候， 多个函数 交替使用，使用yield暂停

27, isinstance('元素',_类型_) --->判断 '元素 ' 是否是 类型  的实例   Iterable(可迭代的)需要导入collections 模块
28, 迭代器
        可以被 next() 函数调用并不断返回下一个值的对象叫做迭代器 Iterator
        生成器是可迭代的，也是一个迭代器
        可迭代的对象 （如列表，元组，字典等） 可以使用 iter(可迭代对象) ，将其转化为迭代器
29, 面向对象相当于活字印刷
30, 所有的类都默认继承object。
      类当中兄弟方法的调用都要依赖 self调用
31, __init__ 表示默认值，在对象之前，默认赋值个每个对象，
    __str__ 在打印对象名的时候，自动触发调用__str__里面的内容，
          def __str__(self):
              return '姓名是：'+self.name
    __new__ 表示创建对象的地址，在init之前，系统有默认的 __new__()方法
    __call__ 将对象当做函数调用，（使用 p()---时候，就会调用__call__内部 ）
    __del__
          对象赋值，赋值的变量指向同一块空间，p=per()  p1= p（p和p1指向同一个空间）
          使用   import sys
                sys.getrefcount(p) 可以查看对这个地址的 引用次数
          del p1   删除 p1 的引用,将 p1 与所引用的地址断开联系，而不影响其他引用
          当一块空间没有任何的 引用的时候 就会执行 __del__ 内存回收（删除
      self表示自己的（表示所创建的按个对象）
32, 类方法。
      定义需要依赖装饰器 ---@classmethod
      类方法中的参数是 cls --是类 而不是对象
      类方法中只能够使用类属性
      类方法可以使用类名调用，而不必先创建对象
      修改和调用 类内部的变量，在对象创建之前
33, 类的属性在 变量名字前 加 __(双杠)，表示私有，类外面不能被访问和调用
      也可以在 init中 的   self.__var
      加入  __var  将属性私有 ，可以加入 set 和 get 函数 进行值得修改和获取，
      也可以通过 set 限制 传入的值
          私有是底层在变量名前做了私有装饰,改变了变量的名称--->   _类名.__变量  也可以通过这样的方式修改（通过dir(类或者对象)查看）
34, 静态方法，使用装饰器  @staticmeted
      不依赖于 self 和 cls ，无需传递任何参数, 同样在对象创建之前
      不能够调用和修改对象的变量和函数，只能通过类名操作 类的变量和方法

35, 子类中调用父类的方法使用   super().方法名()  ---->添加父类的方法在子类的方法中，并重写方法
              def eat():
                super().eat()   #---父类的eat()
                # 也可以使用 父类名.eat()   调用父类
                print("  ")     # ---子类增加部分
36, 继承
      has a （包含）
      is a （继承）
      多继承：广度优先原则，（python2 中是深度优先原则）
      类名.__mro__     ----> 查看搜索顺序
37, 在子类的 参数中放入的是父类的名称
38, from 模块名  import （变量，函数，类等）  就可以直接使用变量或者函数，，
    from 模块名  import *  使用 * 代表全体
    在模块中使用 __all__ = ['','']   限制 import *  所调用的变量名称 ‘内部是可以调用的函数’, 只是在 * 的使用时导入
    所有的导入语句都会加载整个模块，在不希望被加载的内容前面添加
    if __name__ == '__main__'
    就不会加载下面的部分
    在自己的模块中 打印 __name__ 输出的是 __main__
    如果导入到其他模块中使用就会打印 所在得模块名
39, 文件夹和包的区别—— 包中含有 __init__.py 文件，而且包中都是 py 文件 , 包的命名遵循变量命名原则
    包中含有多个模块， 通过  from 包名 import 模块名  导入 ，使用  模块名.类,函数  的方法使用
      也可以使用 from 包名.模块名 import 类名,函数  的方法， 使用 类名. 进行操作
    from 的导入基于当前的项目下，在包内导入 同级文件也需要使用到 包名
    而在包内部的文件导入 包外的文件就 直接使用 from （在同一个项目下）
38, 在包的导入中， 只要导入了包就会  自动调用并执行 __ini__.py 文件   通过 包名. 仅能够调用其中文件
      在包的 导入中，使用 from 包名 import * 导入模块时候，  需要在  __init__.py 文件中添加  __all__=[''] ,加入要调用的变量等，否则无法使用
39,通常在被导入的模块中，调用部分写在 if __name__ == '__main__'之中。
    为了避免文件之间的循环导入问题 ， 可以将 导入语句放在函数中使用
